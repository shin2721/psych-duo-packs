import fs from "fs"; import path from "path";
const UNITS_DIR="data/units_out", OUT_PATH="data/path/path.json", RECIPES_DIR="recipes";
const ENERGY={ max:Number(process.env.ENERGY_MAX||25), regen_ms:Number(process.env.REGEN_MS||3600000), streak_bonuses:{ "5":Number(process.env.STREAK5||1), "10":Number(process.env.STREAK10||3) }, perfect_bonus:Number(process.env.PERFECT||5), cost_per_answer:1 };
function loadSpecs(){ const m=new Map(); if(!fs.existsSync(RECIPES_DIR)) return m; for(const f of fs.readdirSync(RECIPES_DIR).filter(x=>x.endsWith(".json"))){ try{ const s=JSON.parse(fs.readFileSync(path.join(RECIPES_DIR,f),"utf8")); if(s&&s.unit_id) m.set(s.unit_id,s);}catch{} } return m; }
function scanUnits(){ if(!fs.existsSync(UNITS_DIR)) return new Map(); const dirs=fs.readdirSync(UNITS_DIR).filter(d=>fs.statSync(path.join(UNITS_DIR,d)).isDirectory()); const out=new Map(); for(const u of dirs){ const udir=path.join(UNITS_DIR,u); const files=fs.readdirSync(udir).filter(f=>/^n\\d{2}_l\\d{2}\\.jsonl$/.test(f)); if(!files.length) continue; const by=new Map(); for(const f of files){ const m=f.match(/^n(\\d{2})_l(\\d{2})\\.jsonl$/); if(!m) continue; const nid="n"+m[1]; (by.get(nid)||by.set(nid,[]).get(nid)).push(path.join(udir,f)); } for(const [k,arr] of by){ arr.sort((a,b)=>a.localeCompare(b)); by.set(k,arr); } const nodes=[...by.keys()].sort().map(k=>({node_id:k,lessons:by.get(k)})); out.set(u,{unit_id:u,nodes}); } return out; }
function hydrate(meta,specs){ const spec=specs.get(meta.unit_id); const ctx=spec?.context||meta.unit_id.split(".")[0]||"general"; const title=spec?.title||meta.unit_id; const size=spec?.path?.lesson_size||Number(process.env.LESSON_SIZE||15); const lpn=spec?.path?.lessons_per_node||meta.nodes[0]?.lessons?.length||Number(process.env.LESSONS||6); return {...meta, title, context:ctx, lesson_size:size, lessons_per_node:lpn}; }
function autoSections(map){ const buckets=new Map(); for(const [uid] of map){ const ctx=uid.split(".")[0]||"general"; (buckets.get(ctx)||buckets.set(ctx,[]).get(ctx)).push(uid); } return { sections:[...buckets.entries()].map(([ctx,ids])=>({id:ctx+".auto", title:ctx+" セクション", unit_ids:ids.sort()})), auto_include_units:false }; }
function build(){ const specs=loadSpecs(); const scanned=scanUnits(); if(scanned.size===0){ console.error("✗ data/units_out にユニットがありません"); process.exit(1); }
  let secSpec=null; try{ secSpec=JSON.parse(fs.readFileSync("recipes/sections.json","utf8")); }catch{}
  if(!secSpec||!secSpec.sections?.length){ console.warn("! sections.json 無し/空 → 自動でセクション化"); secSpec=autoSections(scanned); }
  const used=new Set(); const sections=[]; for(const s of secSpec.sections){ const units=[]; for(const id of (s.unit_ids||[])){ const meta=scanned.get(id); if(!meta) continue; units.push(hydrate(meta,specs)); used.add(id); } if(units.length) sections.push({id:s.id, title:s.title||s.id, units}); }
  if(secSpec.auto_include_units){ const remain=[...scanned.keys()].filter(id=>!used.has(id)).sort(); if(remain.length) sections.push({id:"auto.remaining", title:"未割当ユニット", units: remain.map(id=>hydrate(scanned.get(id),specs))}); }
  const payload={ version:"1.0", energy:ENERGY, sections }; fs.mkdirSync(require("path").dirname(OUT_PATH),{recursive:true}); fs.writeFileSync(OUT_PATH, JSON.stringify(payload,null,2)+"\n","utf8");
  let U=0,N=0,L=0; for(const s of sections){ U+=s.units.length; for(const u of s.units){ N+=u.nodes.length; for(const n of u.nodes) L+=n.lessons.length; } }
  console.log(`✓ path.json 生成: Sections=${sections.length}, Units=${U}, Nodes=${N}, Lessons=${L}`); console.log("→ 出力:", OUT_PATH);
}
build();
