#!/usr/bin/env node

/**
 * Psycle問題自動生成システム - Duolingo風の楽しい心理学問題を大量生成
 * 完全無料（Claude APIなし）- 論文のtitle/abstractのみ使用
 */

import fs from 'fs';
import path from 'path';

// ================== 心理学用語データベース ==================

const PSYCH_TERMS = {
  therapies: [
    { ja: '認知行動療法', en: 'CBT', desc: '考え方と行動を変える' },
    { ja: 'マインドフルネス', en: 'Mindfulness', desc: '今に集中する練習' },
    { ja: '弁証法的行動療法', en: 'DBT', desc: '感情調整スキルを学ぶ' },
    { ja: '対人関係療法', en: 'IPT', desc: '人間関係の改善に焦点' },
    { ja: '曝露療法', en: 'Exposure Therapy', desc: '恐怖に少しずつ慣れる' },
    { ja: 'アクセプタンス&コミットメント療法', en: 'ACT', desc: '価値に沿って行動する' },
    { ja: '精神分析療法', en: 'Psychoanalysis', desc: '無意識を探る' },
    { ja: 'EMDR', en: 'EMDR', desc: 'トラウマ記憶を処理' },
    { ja: '動機づけ面接', en: 'MI', desc: '変化への動機を高める' },
    { ja: '認知再評価', en: 'Cognitive Reappraisal', desc: '見方を変えて考え直す' },
    { ja: '表出抑制', en: 'Expressive Suppression', desc: '感情をガマンして隠す' },
    { ja: '行動活性化', en: 'Behavioral Activation', desc: '楽しい活動を増やす' },
    { ja: 'ソリューション・フォーカスト', en: 'SFBT', desc: '解決に焦点を当てる' },
    { ja: '家族療法', en: 'Family Therapy', desc: '家族システム全体を治療' },
    { ja: '認知処理療法', en: 'CPT', desc: 'PTSDの認知パターンを変える' },
  ],
  disorders: [
    { ja: 'うつ病', en: 'Depression', symptom: '気分の落ち込み' },
    { ja: '不安症', en: 'Anxiety', symptom: '過度な心配' },
    { ja: 'PTSD', en: 'PTSD', symptom: 'トラウマの再体験' },
    { ja: '強迫性障害', en: 'OCD', symptom: '強迫観念と強迫行為' },
    { ja: 'パニック障害', en: 'Panic Disorder', symptom: '突然の恐怖発作' },
    { ja: '社交不安症', en: 'Social Anxiety', symptom: '人前での強い緊張' },
    { ja: '摂食障害', en: 'Eating Disorder', symptom: '食行動の異常' },
    { ja: 'バーンアウト', en: 'Burnout', symptom: '燃え尽き症候群' },
    { ja: '双極性障害', en: 'Bipolar', symptom: '気分の極端な変動' },
    { ja: '境界性パーソナリティ障害', en: 'BPD', symptom: '感情の不安定さ' },
    { ja: '統合失調症', en: 'Schizophrenia', symptom: '現実認識の障害' },
    { ja: 'ADHD', en: 'ADHD', symptom: '注意散漫・多動性' },
    { ja: '睡眠障害', en: 'Sleep Disorder', symptom: '睡眠の質・量の問題' },
    { ja: '物質使用障害', en: 'Substance Use', symptom: '依存・乱用' },
  ],
  concepts: [
    { ja: '感情調整', en: 'Emotion Regulation', effect: '気持ちをうまく扱う' },
    { ja: 'レジリエンス', en: 'Resilience', effect: '困難から立ち直る力' },
    { ja: 'セルフコンパッション', en: 'Self-Compassion', effect: '自分への優しさ' },
    { ja: 'メタ認知', en: 'Metacognition', effect: '考えについて考える' },
    { ja: 'ストレスコーピング', en: 'Coping', effect: 'ストレス対処法' },
    { ja: 'ソーシャルサポート', en: 'Social Support', effect: '周囲からの支え' },
    { ja: 'ワーキングメモリ', en: 'Working Memory', effect: '短期的な記憶保持' },
    { ja: '実行機能', en: 'Executive Function', effect: '計画・制御能力' },
    { ja: 'アタッチメント', en: 'Attachment', effect: '愛着関係' },
    { ja: 'ニューロフィードバック', en: 'Neurofeedback', effect: '脳活動の可視化訓練' },
    { ja: 'エクスポージャー', en: 'Exposure', effect: '恐怖対象への段階的接触' },
    { ja: 'リラクゼーション', en: 'Relaxation', effect: '心身の緊張緩和' },
    { ja: '認知の歪み', en: 'Cognitive Distortion', effect: '偏った考え方のパターン' },
    { ja: 'エモーショナルインテリジェンス', en: 'EQ', effect: '感情理解能力' },
    { ja: 'フロー状態', en: 'Flow', effect: '没頭して集中する状態' },
    { ja: 'バイアス', en: 'Bias', effect: '無意識の偏見' },
    { ja: 'プラシーボ効果', en: 'Placebo', effect: '思い込みによる変化' },
    { ja: '神経可塑性', en: 'Neuroplasticity', effect: '脳の変化する力' },
  ]
};

// ================== シナリオテンプレート ==================

const SCENARIOS = {
  work_stress: [
    { setup: '締め切りに追われている時', question: 'どう対処する？' },
    { setup: '上司に怒られた後', question: '気持ちをどう整える？' },
    { setup: 'プレゼン前の緊張', question: 'どうする？' },
    { setup: '仕事が山積みでパンク寸前', question: '最初にやるべきは？' },
    { setup: '同僚との意見の食い違い', question: 'どう解決する？' },
  ],
  student: [
    { setup: 'テスト前日に焦っている', question: '効果的な勉強法は？' },
    { setup: '友達関係で悩んでいる', question: 'どう考える？' },
    { setup: '授業中に集中できない', question: 'どうする？' },
    { setup: '失敗を引きずっている', question: 'どう立ち直る？' },
    { setup: '将来の不安が大きい', question: 'どう向き合う？' },
  ],
  daily_life: [
    { setup: '朝起きるのがつらい', question: 'どう改善する？' },
    { setup: '夜なかなか寝付けない', question: 'どうする？' },
    { setup: 'SNSで気分が落ち込んだ', question: 'どう対処する？' },
    { setup: '予定がうまくいかなかった', question: 'どう考える？' },
    { setup: '嫌なニュースを見てしまった', question: 'どうする？' },
  ],
  relationships: [
    { setup: '友達に裏切られた気がする', question: 'どう向き合う？' },
    { setup: 'パートナーと喧嘩した', question: 'どう解決する？' },
    { setup: '人に嫌われるのが怖い', question: 'どう考える？' },
    { setup: '誰とも会いたくない気分', question: 'どうする？' },
    { setup: '褒められても素直に受け取れない', question: 'なぜ？' },
  ],
  health: [
    { setup: '最近疲れやすい', question: '原因は何？' },
    { setup: '頭痛が続いている', question: 'どうする？' },
    { setup: '食欲がない日が続く', question: '考えられる理由は？' },
    { setup: '運動が続かない', question: 'どう工夫する？' },
    { setup: '体調不良を感じるが病院に行けない', question: 'どうする？' },
  ],
  money: [
    { setup: '衝動買いしてしまう', question: 'どう防ぐ？' },
    { setup: '貯金ができない', question: '何から始める？' },
    { setup: 'お金の不安が消えない', question: 'どう考える？' },
    { setup: '高額な買い物を後悔している', question: 'どうする？' },
    { setup: '友達との金銭感覚のズレ', question: 'どう向き合う？' },
  ],
};

// ================== ProblemGenerator クラス ==================

class ProblemGenerator {
  constructor(sources) {
    this.sources = sources.filter(s => s.abstract && s.abstract.length > 100);
    console.log(`✓ Loaded ${this.sources.length} sources with abstracts`);
  }

  // -------------------- ユーティリティ関数 --------------------

  randomChoice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  randomSample(arr, n) {
    const shuffled = [...arr].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, n);
  }

  extractKeywords(text) {
    const keywords = [];
    const lower = text.toLowerCase();

    // 療法名を抽出
    PSYCH_TERMS.therapies.forEach(t => {
      if (lower.includes(t.en.toLowerCase()) || lower.includes(t.ja)) {
        keywords.push({ type: 'therapy', term: t });
      }
    });

    // 障害名を抽出
    PSYCH_TERMS.disorders.forEach(d => {
      if (lower.includes(d.en.toLowerCase()) || lower.includes(d.ja)) {
        keywords.push({ type: 'disorder', term: d });
      }
    });

    // 概念を抽出
    PSYCH_TERMS.concepts.forEach(c => {
      if (lower.includes(c.en.toLowerCase()) || lower.includes(c.ja)) {
        keywords.push({ type: 'concept', term: c });
      }
    });

    return keywords;
  }

  inferContext(paper) {
    const text = `${paper.title} ${paper.abstract}`.toLowerCase();

    // ユニット推定
    const unitHints = {
      mental: ['emotion', 'mood', 'depression', 'anxiety', 'stress', 'mindfulness'],
      work: ['work', 'job', 'burnout', 'occupational', 'employee', 'workplace'],
      study: ['student', 'learning', 'academic', 'education', 'school'],
      health: ['sleep', 'exercise', 'physical', 'health', 'body'],
      social: ['social', 'relationship', 'interpersonal', 'friend'],
      money: ['economic', 'financial', 'money', 'poverty'],
    };

    let unit = 'mental'; // デフォルト
    let maxScore = 0;
    Object.entries(unitHints).forEach(([u, hints]) => {
      const score = hints.filter(h => text.includes(h)).length;
      if (score > maxScore) {
        maxScore = score;
        unit = u;
      }
    });

    return { unit, keywords: this.extractKeywords(text) };
  }

  getDifficulty() {
    const rand = Math.random();
    if (rand < 0.4) return 'easy';
    if (rand < 0.8) return 'medium';
    return 'hard';
  }

  // -------------------- 問題生成関数 --------------------

  // 1. シナリオクイズ
  generateScenario() {
    const category = this.randomChoice(Object.keys(SCENARIOS));
    const scenario = this.randomChoice(SCENARIOS[category]);
    const paper = this.randomChoice(this.sources);
    const keywords = this.extractKeywords(paper.abstract);

    if (keywords.length === 0) return null;

    const keyword = this.randomChoice(keywords);
    const term = keyword.term;

    const choices = [
      `${term.ja}を試してみる`,
      '何もせずに我慢する',
      '誰かに愚痴る',
    ];

    return {
      id: `scenario_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `${scenario.setup}。${scenario.question}`,
      choices: this.randomSample(choices, 3),
      answer_index: 0,
      info: `研究より: ${term.ja}が効果的`,
      difficulty: this.getDifficulty(),
      source_id: paper.id,
    };
  }

  // 2. どっちクイズ
  generateWhichOne() {
    const therapies = PSYCH_TERMS.therapies;
    const t1 = this.randomChoice(therapies);
    const t2 = this.randomChoice(therapies.filter(t => t.ja !== t1.ja));
    const disorder = this.randomChoice(PSYCH_TERMS.disorders);

    return {
      id: `whichone_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'ab',
      stem: `${disorder.ja}に効果的なのはどっち？`,
      choices: [t1.ja, t2.ja],
      answer_index: Math.random() < 0.5 ? 0 : 1,
      info: `どちらも効果があるが文脈次第`,
      difficulty: 'easy',
    };
  }

  // 3. ○×クイズ
  generateTrueFalse() {
    const paper = this.randomChoice(this.sources);
    const keywords = this.extractKeywords(paper.abstract);

    if (keywords.length === 0) return null;

    const keyword = this.randomChoice(keywords);
    const term = keyword.term;

    const statements = [
      `${term.ja}は${this.randomChoice(PSYCH_TERMS.disorders).ja}に効果がある`,
      `${term.ja}は誰にでも効く万能な方法だ`,
      `${term.ja}は科学的根拠がない`,
    ];

    return {
      id: `tf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'truefalse',
      stem: this.randomChoice(statements),
      choices: ['正しい', '誤り'],
      answer_index: Math.random() < 0.7 ? 0 : 1,
      info: `${paper.title.substring(0, 50)}...より`,
      difficulty: this.getDifficulty(),
      source_id: paper.id,
    };
  }

  // 4. 感情クイズ
  generateEmotionQuiz() {
    const emotions = ['不安', '怒り', '悲しみ', '喜び', '恐れ'];
    const emotion = this.randomChoice(emotions);
    const strategies = this.randomSample(PSYCH_TERMS.therapies, 3);

    return {
      id: `emotion_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `${emotion}を感じた時、効果的な対処法は？`,
      choices: strategies.map(s => s.ja),
      answer_index: 0,
      info: `${strategies[0].desc}`,
      difficulty: 'easy',
    };
  }

  // 5. セラピスト役
  generateTherapistRole() {
    const scenario = this.randomChoice(SCENARIOS.work_stress.concat(SCENARIOS.student));
    const therapies = this.randomSample(PSYCH_TERMS.therapies, 3);

    return {
      id: `therapist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `クライアント「${scenario.setup}んです…」\nあなた(セラピスト)の対応は？`,
      choices: therapies.map(t => `${t.desc}をおすすめする`),
      answer_index: 0,
      info: `${therapies[0].ja}アプローチ`,
      difficulty: 'medium',
    };
  }

  // 6. 研究批評
  generateResearchCritique() {
    const paper = this.randomChoice(this.sources);
    const flaws = [
      'サンプルサイズが小さすぎる',
      '因果関係が証明できていない',
      '再現性が確認されていない',
      'バイアスの可能性がある',
    ];

    return {
      id: `critique_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `この研究の限界は？\n「${paper.title.substring(0, 60)}...」`,
      choices: this.randomSample(flaws, 3),
      answer_index: Math.floor(Math.random() * 3),
      info: '研究の限界を理解することが重要',
      difficulty: 'hard',
      source_id: paper.id,
    };
  }

  // 7. コンセプト応用
  generateConceptApplication() {
    const concept = this.randomChoice(PSYCH_TERMS.concepts);
    const scenario = this.randomChoice(SCENARIOS.daily_life);

    const applications = [
      `${concept.effect}を実践する`,
      '何もせず時間が解決するのを待つ',
      '誰かに相談する',
    ];

    return {
      id: `concept_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `${scenario.setup}。\n${concept.ja}ならどうする？`,
      choices: applications,
      answer_index: 0,
      info: `${concept.ja}とは: ${concept.effect}`,
      difficulty: 'medium',
    };
  }

  // 8. データ解釈
  generateDataInterpretation() {
    const therapy = this.randomChoice(PSYCH_TERMS.therapies);
    const percentage = 60 + Math.floor(Math.random() * 30);

    const interpretations = [
      `${therapy.ja}は効果がある`,
      `${therapy.ja}は誰にでも効く`,
      `${therapy.ja}は完全に症状を治す`,
    ];

    return {
      id: `data_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `研究結果: ${therapy.ja}で${percentage}%が改善。\nこれは何を意味する？`,
      choices: interpretations,
      answer_index: 0,
      info: '改善≠完治。効果には個人差がある',
      difficulty: 'hard',
    };
  }

  // 9. 倫理ジレンマ
  generateEthicalDilemma() {
    const dilemmas = [
      { setup: 'クライアントが危険な行動を計画している', question: 'どうする？' },
      { setup: '治療効果がないが本人は満足している', question: '続けるべき？' },
      { setup: '家族が本人の意思に反して治療を望んでいる', question: 'どうする？' },
    ];

    const dilemma = this.randomChoice(dilemmas);

    return {
      id: `ethics_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `倫理的問題: ${dilemma.setup}。${dilemma.question}`,
      choices: [
        '守秘義務より安全を優先',
        '本人の意思を最優先',
        '専門家に相談する',
      ],
      answer_index: 2,
      info: '倫理ガイドラインに従う',
      difficulty: 'hard',
    };
  }

  // 10. 研究バトル
  generateResearchBattle() {
    const papers = this.randomSample(this.sources, 2);

    return {
      id: `battle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'ab',
      stem: 'どちらの研究が信頼できる？',
      choices: [
        `A: ${papers[0].title.substring(0, 50)}...`,
        `B: ${papers[1].title.substring(0, 50)}...`,
      ],
      answer_index: Math.random() < 0.5 ? 0 : 1,
      info: 'どちらも査読済み論文',
      difficulty: 'medium',
      source_id: papers[0].id,
    };
  }

  // 11. 限界発見
  generateLimitationFinder() {
    const paper = this.randomChoice(this.sources);
    const limitations = [
      '横断研究なので因果は不明',
      'サンプルが偏っている可能性',
      '長期効果は未検証',
    ];

    return {
      id: `limit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `研究「${paper.title.substring(0, 50)}...」\nの限界は？`,
      choices: this.randomSample(limitations, 3),
      answer_index: 0,
      info: '研究の限界を知ることが科学的思考',
      difficulty: 'hard',
      source_id: paper.id,
    };
  }

  // 12. バイアス検出
  generateBiasDetection() {
    const biases = [
      { name: '確証バイアス', desc: '自分の信念を支持する情報だけ集める' },
      { name: '生存者バイアス', desc: '成功者だけ見て失敗者を無視' },
      { name: '後知恵バイアス', desc: '結果を知ってから「わかってた」と思う' },
    ];

    const bias = this.randomChoice(biases);

    return {
      id: `bias_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: '「成功した人の本ばかり読んで、失敗例は無視」\nこれは何バイアス？',
      choices: biases.map(b => b.name),
      answer_index: biases.findIndex(b => b.name === bias.name),
      info: `${bias.name}: ${bias.desc}`,
      difficulty: 'medium',
    };
  }

  // 13. 治療マッチング
  generateTreatmentMatching() {
    const disorder = this.randomChoice(PSYCH_TERMS.disorders);
    const therapies = this.randomSample(PSYCH_TERMS.therapies, 3);

    return {
      id: `match_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'mcq3',
      stem: `${disorder.ja}(${disorder.symptom})に\n最も適した治療法は？`,
      choices: therapies.map(t => t.ja),
      answer_index: 0,
      info: `${therapies[0].desc}が効果的`,
      difficulty: 'medium',
    };
  }

  // 14. 穴埋め (clozeN)
  generateCloze() {
    const therapy = this.randomChoice(PSYCH_TERMS.therapies);
    const disorder = this.randomChoice(PSYCH_TERMS.disorders);

    const templates = [
      { text: '［1］は［2］に効果がある', key: { '1': therapy.ja, '2': disorder.ja } },
      { text: '［1］の症状には［2］が有効', key: { '1': disorder.ja, '2': therapy.ja } },
    ];

    const template = this.randomChoice(templates);
    const wrongTherapy = this.randomChoice(PSYCH_TERMS.therapies.filter(t => t.ja !== therapy.ja));
    const wrongDisorder = this.randomChoice(PSYCH_TERMS.disorders.filter(d => d.ja !== disorder.ja));

    return {
      id: `cloze_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'clozeN',
      text: template.text,
      bank: [therapy.ja, disorder.ja, wrongTherapy.ja, wrongDisorder.ja].slice(0, 4),
      key: template.key,
      info: '基本的な知識',
      difficulty: 'easy',
    };
  }

  // 15. ランキング (rank)
  generateRank() {
    const items = this.randomSample(PSYCH_TERMS.therapies, 3);

    return {
      id: `rank_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'rank',
      stem: '効果の大きさ順に並べ替えよう（研究データより）',
      items: items.map(t => t.ja),
      correct_order: [0, 1, 2],
      info: 'エビデンスレベルは研究により異なる',
      difficulty: 'hard',
    };
  }

  // -------------------- メイン生成関数 --------------------

  generate_question(type = null) {
    const generators = {
      scenario: () => this.generateScenario(),
      whichone: () => this.generateWhichOne(),
      truefalse: () => this.generateTrueFalse(),
      emotion: () => this.generateEmotionQuiz(),
      therapist: () => this.generateTherapistRole(),
      critique: () => this.generateResearchCritique(),
      concept: () => this.generateConceptApplication(),
      data: () => this.generateDataInterpretation(),
      ethics: () => this.generateEthicalDilemma(),
      battle: () => this.generateResearchBattle(),
      limit: () => this.generateLimitationFinder(),
      bias: () => this.generateBiasDetection(),
      match: () => this.generateTreatmentMatching(),
      cloze: () => this.generateCloze(),
      rank: () => this.generateRank(),
    };

    if (type && generators[type]) {
      return generators[type]();
    }

    // ランダム選択
    const types = Object.keys(generators);
    const selectedType = this.randomChoice(types);
    return generators[selectedType]();
  }

  generate_lesson(unit = 'mental', size = 15) {
    const questions = [];
    const targetDistribution = {
      easy: Math.floor(size * 0.4),
      medium: Math.floor(size * 0.4),
      hard: size - Math.floor(size * 0.4) - Math.floor(size * 0.4),
    };

    const counts = { easy: 0, medium: 0, hard: 0 };

    while (questions.length < size) {
      const q = this.generate_question();
      if (!q) continue;

      const difficulty = q.difficulty || 'medium';
      if (counts[difficulty] < targetDistribution[difficulty]) {
        questions.push(q);
        counts[difficulty]++;
      }
    }

    return questions;
  }

  generate_node(unit = 'mental', node_num = 1) {
    const lessonSize = 15;
    const lesson = this.generate_lesson(unit, lessonSize);

    return {
      node: node_num,
      unit: unit,
      size: lessonSize,
      questions: lesson,
    };
  }
}

// ================== CLI メイン処理 ==================

async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'help';

  // データ読み込み
  const sourcesPath = path.join(process.cwd(), 'data', 'sources.json');
  const sources = JSON.parse(fs.readFileSync(sourcesPath, 'utf-8'));

  const generator = new ProblemGenerator(sources);

  switch (command) {
    case 'question': {
      const type = args[1];
      const q = generator.generate_question(type);
      console.log(JSON.stringify(q, null, 2));
      break;
    }

    case 'lesson': {
      const unit = args[1] || 'mental';
      const size = parseInt(args[2]) || 15;
      const lesson = generator.generate_lesson(unit, size);
      console.log(JSON.stringify(lesson, null, 2));
      break;
    }

    case 'node': {
      const unit = args[1] || 'mental';
      const nodeNum = parseInt(args[2]) || 1;
      const node = generator.generate_node(unit, nodeNum);

      const outputDir = path.join(process.cwd(), 'data', 'lessons_variety');
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      const filename = `${unit}_l${String(nodeNum).padStart(2, '0')}.json`;
      const outputPath = path.join(outputDir, filename);
      fs.writeFileSync(outputPath, JSON.stringify(node.questions, null, 2));
      console.log(`✓ Generated: ${outputPath}`);
      break;
    }

    case 'all': {
      const units = ['mental', 'work', 'study', 'health', 'social', 'money'];
      const nodesPerUnit = 6;

      for (const unit of units) {
        for (let i = 1; i <= nodesPerUnit; i++) {
          const node = generator.generate_node(unit, i);

          const outputDir = path.join(process.cwd(), 'data', 'lessons_variety');
          if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
          }

          const filename = `${unit}_l${String(i).padStart(2, '0')}.json`;
          const outputPath = path.join(outputDir, filename);
          fs.writeFileSync(outputPath, JSON.stringify(node.questions, null, 2));
          console.log(`✓ Generated: ${outputPath}`);
        }
      }

      console.log(`\n✅ Complete! Generated ${units.length * nodesPerUnit} lessons.`);
      break;
    }

    default:
      console.log(`
Psycle問題自動生成システム

使い方:
  node auto_generate_problems.mjs question [type]     # 1問だけ生成
  node auto_generate_problems.mjs lesson [unit] [size] # レッスン生成
  node auto_generate_problems.mjs node [unit] [num]    # ノード生成
  node auto_generate_problems.mjs all                  # 全ユニット生成

問題タイプ:
  scenario, whichone, truefalse, emotion, therapist,
  critique, concept, data, ethics, battle, limit,
  bias, match, cloze, rank

例:
  node auto_generate_problems.mjs question scenario
  node auto_generate_problems.mjs lesson mental 15
  node auto_generate_problems.mjs node work 1
  node auto_generate_problems.mjs all
      `);
  }
}

main().catch(console.error);
